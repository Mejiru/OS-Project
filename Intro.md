This project involves the simulation of three core operating system concepts: process scheduling, deadlock avoidance, and memory management. We developed a program which demonstrates our understanding of these concepts. This program was developed with the aim of allowing users to interact with these OS algorithms with their own inputs and see how the program responds to different inputs. We have decided to take a modular approach, which not only aids us to split the work for each individual, but also debug the code a lot quicker and keep the code more organized.  

Firstly, Part I focuses on CPU scheduling, where the program allows the user to enter the number of processes along with their arrival and burst times, and a quantum for Round Robin. The program then runs four scheduling algorithms: FCFS, SJF Non-Preemptive, SJF Preemptive, and Round Robin calculating performance metrics such as waiting time and turnaround time, while also generating Gantt charts to visualize process execution. Secondly, Part II simulates the Bankerâ€™s Algorithm, which ensures deadlock avoidance by asking the user to provide the number of processes, resource types, and the current allocation and maximum resources for each process. The system computes the Need matrix and tests resource requests by temporarily allocating resources and checking whether the system remains in a safe state, granting or denying requests accordingly. Finally, in Part III we illustrate how Page replacement for the sake of memory management works in the OS. When chosen, the system asks the user to input the reference string and the frame number. Afterwards, the program will simulate the 3 page-replacement algorithms that we discussed during the lectures: FIFO, LRU and Optimal. Additionally, the program also computes hit ratios, page faults and miss ratios while showing how the memory frames change each time a new page from the reference string searches for a frame.  

Altogether, this project shows how operating systems make important decisions in scheduling, managing resources, and handling memory, while letting the user see how different algorithms behave, track process execution with Gantt charts, calculate waiting and turnaround times, test safe and unsafe resource requests, and compare page replacement methods based on page faults, hits, and misses.  
